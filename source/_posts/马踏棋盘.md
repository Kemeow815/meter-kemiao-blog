---
title: 马踏棋盘
banner_img: https://cdn.studyinglover.com/pic/2023/10/0863cb015e8d69fbce68ebe57bea96d8.jpg
date: 2023-10-12 9:39:00
categories:
- 踩坑
---
```c
#include <stdio.h>
#include <stdbool.h>

#define SIZE 8

int move_x[8] = {2, 1, -1, -2, -2, -1, 1, 2};
int move_y[8] = {1, 2, 2, 1, -1, -2, -2, -1};

bool is_valid_move(int x, int y, int board[SIZE][SIZE]) {
    if (x >= 0 && x < SIZE && y >= 0 && y < SIZE && board[x][y] == -1) {
        return true;
    }
    return false;
}

void print_board(int board[SIZE][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%2d ", board[i][j]);
        }
        printf("\n");
    }
}

void solve_knight_tour(int start_x, int start_y) {
    int board[SIZE][SIZE];
    int move_count = 1;

    // 初始化棋盘
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            board[i][j] = -1;
        }
    }

    int x = start_x;
    int y = start_y;
    board[x][y] = move_count;

    while (move_count < SIZE * SIZE) {
        int min_deg = SIZE + 1;
        int min_index = -1;
        int next_x, next_y;

        // 尝试所有可能的移动
        for (int i = 0; i < 8; i++) {
            next_x = x + move_x[i];
            next_y = y + move_y[i];

            if (is_valid_move(next_x, next_y, board)) {
                int deg = 0;

                // 计算下一个位置的度数
                for (int j = 0; j < 8; j++) {
                    int new_x = next_x + move_x[j];
                    int new_y = next_y + move_y[j];
                    
                    if (is_valid_move(new_x, new_y, board)) {
                        deg++;
                    }
                }

                // 更新最小度数和对应的索引
                if (deg < min_deg) {
                    min_deg = deg;
                    min_index = i;
                }
            }
        }

        // 没有找到合适的下一步移动位置
        if (min_index == -1) {
            break;
        }

        // 移动到下一个位置
        x += move_x[min_index];
        y += move_y[min_index];
        board[x][y] = ++move_count;
    }

    // 输出结果
    print_board(board);
}

int main(int argc, char *argv[]) {
    int start_x, start_y;

    // printf("请输入马的初始位置（x, y）：");
    // scanf("%d %d", &start_x, &start_y);
    // start_x = 2;
    // start_y = 2;
    start_x = *argv[1] - '0';
    start_y = *argv[2] - '0';
    // printf("%d %d",start_x,start_y);

    solve_knight_tour(start_x, start_y);

    return 0;
}
```

```python
import sys
from time import sleep
import numpy as np
import matplotlib.pyplot as plt

lines = sys.stdin.readlines()

# 删除换行符并转换为整数
lines = np.array([list(map(int, line.strip().split())) for line in lines])

# lines是一个矩阵，每个点的值代表该点的访问顺序
# 例如，lines[0][0] = 1，代表第一个访问的点是(0, 0)
# lines[0][1] = 34，代表第三十四个访问的点是(0, 1)
# lines[1][0] = 4，代表第四个访问的点是(1, 0)

order_x = []
order_y = []

count = 1
while count <= len(lines)**2:
    for i in range(len(lines)):
        for j in range(len(lines)):
            if lines[i][j] == count:
                order_x.append(i)
                order_y.append(j)
                count += 1


# 绘制棋盘
plt.figure(figsize=(8, 8))

# 绘制棋盘的格子
for i in range(len(lines)+1):
    plt.plot([i, i], [0, len(lines)], color='black')
    plt.plot([0, len(lines)], [i, i], color='black')

count = 1
# 绘制马的行走路线
for i in range(len(order_x)-1):
    plt.plot([order_x[i]+0.5, order_x[i+1]+0.5], [order_y[i]+0.5, order_y[i+1]+0.5], color='red', )
    plt.scatter(order_x[i]+0.5, order_y[i]+0.5, color='red')
    # 加上序号
    plt.text(order_x[i]+0.5, order_y[i]+0.5, str(count), fontsize=12)
    count += 1
    plt.pause(0.01)
    
# 绘制最后一个点
plt.scatter(order_x[-1]+0.5, order_y[-1]+0.5, color='red')
plt.text(order_x[-1]+0.6, order_y[-1]+0.6, str(count), fontsize=12)
plt.show()

```